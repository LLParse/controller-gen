package generators

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/golang/glog"
	"k8s.io/code-generator/cmd/client-gen/generators/util"
	clientgentypes "k8s.io/code-generator/cmd/client-gen/types"
	"k8s.io/gengo/args"
	"k8s.io/gengo/generator"
	"k8s.io/gengo/namer"
	"k8s.io/gengo/types"

	customargs "github.com/llparse/controller-gen/args"
)

// NameSystems returns the name system used by the generators in this package.
func NameSystems() namer.NameSystems {
	pluralExceptions := map[string]string{
		"Endpoints": "Endpoints",
	}
	return namer.NameSystems{
		"public":             namer.NewPublicNamer(0),
		"private":            namer.NewPrivateNamer(0),
		"raw":                namer.NewRawNamer("", nil),
		"publicPlural":       namer.NewPublicPluralNamer(pluralExceptions),
		"allLowercasePlural": namer.NewAllLowercasePluralNamer(pluralExceptions),
		"lowercaseSingular":  &lowercaseSingularNamer{},
	}
}

// lowercaseSingularNamer implements Namer
type lowercaseSingularNamer struct{}

// Name returns t's name in all lowercase.
func (n *lowercaseSingularNamer) Name(t *types.Type) string {
	return strings.ToLower(t.Name.Name)
}

// DefaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func DefaultNameSystem() string {
	return "public"
}

// generatedBy returns information about the arguments used to invoke
// controller-gen.
func generatedBy() string {
	return fmt.Sprintf("\n// This file was automatically generated by controller-gen\n\n")
}

// Packages makes the client package definition.
func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
	boilerplate, err := arguments.LoadGoBoilerplate()
	if err != nil {
		glog.Fatalf("Failed loading boilerplate: %v", err)
	}

	boilerplate = append(boilerplate, []byte(generatedBy())...)

	customArgs, ok := arguments.CustomArgs.(customargs.Args)
	if !ok {
		glog.Fatalf("cannot convert arguments.CustomArgs to customargs.Args")
	}

	var typesToGenerate []*types.Type
	for _, inputDir := range arguments.InputDirs {
		p := context.Universe.Package(inputDir)

		objectMeta, internal, err := objectMetaForPackage(p)
		if err != nil {
			glog.Fatal(err)
		}
		if objectMeta == nil {
			// no types in this package had genclient
			continue
		}
		glog.V(3).Infof("objectMeta: %+v\n", objectMeta)
		glog.V(3).Infof("internal: %+v\n", internal)

		var gv clientgentypes.GroupVersion
		// var internalGVPkg string

		if internal {
			lastSlash := strings.LastIndex(p.Path, "/")
			if lastSlash == -1 {
				glog.Fatalf("error constructing internal group version for package %q", p.Path)
			}
			gv.Group = clientgentypes.Group(p.Path[lastSlash+1:])
			// internalGVPkg = p.Path
		} else {
			parts := strings.Split(p.Path, "/")
			gv.Group = clientgentypes.Group(parts[len(parts)-2])
			gv.Version = clientgentypes.Version(parts[len(parts)-1])
			glog.V(3).Infof("gv: %+v\n", gv)
			// internalGVPkg = strings.Join(parts[0:len(parts)-1], "/")
		}

		// If there's a comment of the form "// +groupName=somegroup" or
		// "// +groupName=somegroup.foo.bar.io", use the first field (somegroup) as the name of the
		// group when generating.
		if override := types.ExtractCommentTags("+", p.DocComments)["groupName"]; override != nil {
			gv.Group = clientgentypes.Group(strings.SplitN(override[0], ".", 2)[0])
			glog.V(3).Infof("gv override: %+v\n", gv)
		}

		for k, v := range p.Types {
			glog.V(3).Infof("%+v: %+v", k, v)
		}
		for name, t := range p.Types {
			tags := util.MustParseClientGenTags(t.SecondClosestCommentLines)
			if !tags.GenerateClient || !tags.HasVerb("list") || !tags.HasVerb("get") {
				continue
			}
			for _, resourceType := range customArgs.ResourceTypes {
				if strings.EqualFold(resourceType, name) {
					typesToGenerate = append(typesToGenerate, t)
					break
				}
			}
		}
		if len(typesToGenerate) == 0 {
			continue
		}
		orderer := namer.Orderer{Namer: namer.NewPrivateNamer(0)}
		typesToGenerate = orderer.OrderTypes(typesToGenerate)
	}

	if len(typesToGenerate) == 0 {
		glog.Fatalf("no valid types were specified")
	}

	glog.V(3).Infof("Types to generate: %+v", typesToGenerate)

	var packageList generator.Packages

	controllerPackagePath := filepath.Join(arguments.OutputPackagePath, "pkg", "controller", customArgs.Name)
	packageList = append(packageList, &generator.DefaultPackage{
		PackageName: customArgs.Name,
		PackagePath: controllerPackagePath,
		HeaderText:  boilerplate,
		GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
			generators = append(generators, &controllerGenerator{
				DefaultGen: generator.DefaultGen{
					OptionalName: "controller",
				},
				packagePath: filepath.Join(arguments.OutputBase, controllerPackagePath),
				imports:     generator.NewImportTracker(),
				name:        customArgs.Name,
				types:       typesToGenerate,
			})
			return generators
		},
		FilterFunc: func(c *generator.Context, t *types.Type) bool {
			tags := util.MustParseClientGenTags(t.SecondClosestCommentLines)
			return tags.GenerateClient && tags.HasVerb("list") && tags.HasVerb("get")
		},
	})

	controllerMainPackagePath := filepath.Join(arguments.OutputPackagePath, "cmd", "controller", customArgs.Name)
	packageList = append(packageList, &generator.DefaultPackage{
		PackageName: "main",
		PackagePath: controllerMainPackagePath,
		HeaderText:  boilerplate,
		GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
			generators = append(generators, &controllerMainGenerator{
				DefaultGen: generator.DefaultGen{
					OptionalName: "main",
				},
				controllerPackagePath: controllerPackagePath,
				packagePath:           filepath.Join(arguments.OutputBase, controllerMainPackagePath),
				imports:               generator.NewImportTracker(),
				name:                  customArgs.Name,
				types:                 typesToGenerate,
			})
			return generators
		},
		FilterFunc: func(c *generator.Context, t *types.Type) bool {
			tags := util.MustParseClientGenTags(t.SecondClosestCommentLines)
			return tags.GenerateClient && tags.HasVerb("list") && tags.HasVerb("get")
		},
	})

	return packageList
}

// objectMetaForPackage returns the type of ObjectMeta used by package p.
func objectMetaForPackage(p *types.Package) (*types.Type, bool, error) {
	generatingForPackage := false
	for _, t := range p.Types {
		// filter out types which dont have genclient.
		if !util.MustParseClientGenTags(t.SecondClosestCommentLines).GenerateClient {
			continue
		}
		generatingForPackage = true
		for _, member := range t.Members {
			if member.Name == "ObjectMeta" {
				return member.Type, isInternal(member), nil
			}
		}
	}
	if generatingForPackage {
		return nil, false, fmt.Errorf("unable to find ObjectMeta for any types in package %s", p.Path)
	}
	return nil, false, nil
}

// isInternal returns true if the tags for a member do not contain a json tag
func isInternal(m types.Member) bool {
	return !strings.Contains(m.Tags, "json")
}
