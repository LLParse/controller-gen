package generators

import (
  "fmt"
  "path/filepath"
  "strings"

  "k8s.io/gengo/args"
  "k8s.io/gengo/generator"
  "k8s.io/gengo/namer"
  "k8s.io/gengo/types"

  "k8s.io/code-generator/cmd/client-gen/generators/util"
  clientgentypes "k8s.io/code-generator/cmd/client-gen/types"

  "github.com/golang/glog"
)

// NameSystems returns the name system used by the generators in this package.
func NameSystems() namer.NameSystems {
  pluralExceptions := map[string]string{
    "Endpoints": "Endpoints",
  }
  return namer.NameSystems{
    "public":             namer.NewPublicNamer(0),
    "private":            namer.NewPrivateNamer(0),
    "raw":                namer.NewRawNamer("", nil),
    "publicPlural":       namer.NewPublicPluralNamer(pluralExceptions),
    "allLowercasePlural": namer.NewAllLowercasePluralNamer(pluralExceptions),
    "lowercaseSingular":  &lowercaseSingularNamer{},
  }
}

// lowercaseSingularNamer implements Namer
type lowercaseSingularNamer struct{}

// Name returns t's name in all lowercase.
func (n *lowercaseSingularNamer) Name(t *types.Type) string {
  return strings.ToLower(t.Name.Name)
}

// DefaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func DefaultNameSystem() string {
  return "public"
}

// generatedBy returns information about the arguments used to invoke
// controller-gen.
func generatedBy() string {
  return fmt.Sprintf("\n// This file was automatically generated by controller-gen\n\n")
}

// Packages makes the client package definition.
func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
  boilerplate, err := arguments.LoadGoBoilerplate()
  if err != nil {
    glog.Fatalf("Failed loading boilerplate: %v", err)
  }

  boilerplate = append(boilerplate, []byte(generatedBy())...)

  var packageList generator.Packages

  for _, inputDir := range arguments.InputDirs {
    p := context.Universe.Package(inputDir)

    objectMeta, internal, err := objectMetaForPackage(p)
    if err != nil {
      glog.Fatal(err)
    }
    if objectMeta == nil {
      // no types in this package had genclient
      continue
    }

    var gv clientgentypes.GroupVersion
    // var internalGVPkg string

    if internal {
      lastSlash := strings.LastIndex(p.Path, "/")
      if lastSlash == -1 {
        glog.Fatalf("error constructing internal group version for package %q", p.Path)
      }
      gv.Group = clientgentypes.Group(p.Path[lastSlash+1:])
      // internalGVPkg = p.Path
    } else {
      parts := strings.Split(p.Path, "/")
      gv.Group = clientgentypes.Group(parts[len(parts)-2])
      gv.Version = clientgentypes.Version(parts[len(parts)-1])

      // internalGVPkg = strings.Join(parts[0:len(parts)-1], "/")
    }

    // If there's a comment of the form "// +groupName=somegroup" or
    // "// +groupName=somegroup.foo.bar.io", use the first field (somegroup) as the name of the
    // group when generating.
    if override := types.ExtractCommentTags("+", p.DocComments)["groupName"]; override != nil {
      gv.Group = clientgentypes.Group(strings.SplitN(override[0], ".", 2)[0])
    }

    var typesToGenerate []*types.Type
    for _, t := range p.Types {
      tags := util.MustParseClientGenTags(t.SecondClosestCommentLines)
      if !tags.GenerateClient || !tags.HasVerb("list") || !tags.HasVerb("get") {
        continue
      }
      typesToGenerate = append(typesToGenerate, t)
    }
    if len(typesToGenerate) == 0 {
      continue
    }
    orderer := namer.Orderer{Namer: namer.NewPrivateNamer(0)}
    typesToGenerate = orderer.OrderTypes(typesToGenerate)

    packagePath := filepath.Join(arguments.OutputPackagePath, strings.ToLower(gv.Group.NonEmpty()), strings.ToLower(gv.Version.NonEmpty()))
    packageList = append(packageList, &generator.DefaultPackage{
      PackageName: strings.ToLower(gv.Version.NonEmpty()),
      PackagePath: packagePath,
      HeaderText:  boilerplate,
      GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
        generators = append(generators, &expansionGenerator{
          DefaultGen: generator.DefaultGen{
            OptionalName: "expansion_generated",
          },
          packagePath: filepath.Join(arguments.OutputBase, packagePath),
          types:       typesToGenerate,
        })
        return generators
      },
      FilterFunc: func(c *generator.Context, t *types.Type) bool {
        tags := util.MustParseClientGenTags(t.SecondClosestCommentLines)
        return tags.GenerateClient && tags.HasVerb("list") && tags.HasVerb("get")
      },
    })
  }

  return packageList
}

// objectMetaForPackage returns the type of ObjectMeta used by package p.
func objectMetaForPackage(p *types.Package) (*types.Type, bool, error) {
  generatingForPackage := false
  for _, t := range p.Types {
    // filter out types which dont have genclient.
    if !util.MustParseClientGenTags(t.SecondClosestCommentLines).GenerateClient {
      continue
    }
    generatingForPackage = true
    for _, member := range t.Members {
      if member.Name == "ObjectMeta" {
        return member.Type, isInternal(member), nil
      }
    }
  }
  if generatingForPackage {
    return nil, false, fmt.Errorf("unable to find ObjectMeta for any types in package %s", p.Path)
  }
  return nil, false, nil
}

// isInternal returns true if the tags for a member do not contain a json tag
func isInternal(m types.Member) bool {
  return !strings.Contains(m.Tags, "json")
}
