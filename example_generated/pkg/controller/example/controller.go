// This file was automatically generated by controller-gen

package example

import (
	"time"

	"github.com/golang/glog"
	"k8s.io/apimachinery/pkg/util/wait"
	core_v1 "k8s.io/client-go/informers/core/v1"
	kubernetes "k8s.io/client-go/kubernetes"
	v1 "k8s.io/client-go/listers/core/v1"
	cache "k8s.io/client-go/tools/cache"
	workqueue "k8s.io/client-go/util/workqueue"
)

type Controller struct {
	// FIXME make dynamic
	kubeClient kubernetes.Interface

	podLister       v1.PodLister
	podListerSynced cache.InformerSynced

	// FIXME make dynamic
	podQueue workqueue.RateLimitingInterface
}

func NewController(
	// FIXME make dynamic
	kubeClient kubernetes.Interface,
	podInformer core_v1.PodInformer,
) *Controller {
	ctrl := &Controller{
		kubeClient: kubeClient,
		// FIXME make dynamic
		podQueue: workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "pod"),
	}

	// FIXME make dynamic
	podInformer.Informer().AddEventHandler(
		cache.ResourceEventHandlerFuncs{
			AddFunc:    func(obj interface{}) { ctrl.enqueueWork(ctrl.podQueue, obj) },
			UpdateFunc: func(oldObj, newObj interface{}) { ctrl.enqueueWork(ctrl.podQueue, newObj) },
			DeleteFunc: func(obj interface{}) { ctrl.enqueueWork(ctrl.podQueue, obj) },
		},
	)

	ctrl.podLister = podInformer.Lister()
	ctrl.podListerSynced = podInformer.Informer().HasSynced

	return ctrl
}

func (ctrl *Controller) Run(stopCh <-chan struct{}) {
	// FIXME make dynamic
	defer ctrl.podQueue.ShutDown()

	glog.Infof("Starting example controller")
	defer glog.Infof("Shutting down example Controller")

	// FIXME make dynamic
	if !cache.WaitForCacheSync(stopCh, ctrl.podListerSynced) {
		return
	}

	// FIXME make dynamic
	go wait.Until(ctrl.podWorker, time.Second, stopCh)

	<-stopCh
}

func (ctrl *Controller) enqueueWork(queue workqueue.Interface, obj interface{}) {
	// Beware of "xxx deleted" events
	if unknown, ok := obj.(cache.DeletedFinalStateUnknown); ok && unknown.Obj != nil {
		obj = unknown.Obj
	}
	objName, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)
	if err != nil {
		glog.Errorf("failed to get key from object: %v", err)
		return
	}
	glog.V(5).Infof("enqueued %q for sync", objName)
	queue.Add(objName)
}

// FIXME make dynamic
func (ctrl *Controller) podWorker() {
	workFunc := func() bool {
		keyObj, quit := ctrl.podQueue.Get()
		if quit {
			return true
		}
		defer ctrl.podQueue.Done(keyObj)
		key := keyObj.(string)
		glog.V(5).Infof("podWorker[%s]", key)
		return false
	}
	for {
		if quit := workFunc(); quit {
			glog.Infof("pod worker queue shutting down")
			return
		}
	}
}
